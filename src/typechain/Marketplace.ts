/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export type ListingStruct = {
  status: BigNumberish;
  seller: string;
  price: BigNumberish;
  token: string;
  tokenId: BigNumberish;
};

export type ListingStructOutput = [
  number,
  string,
  BigNumber,
  string,
  BigNumber
] & {
  status: number;
  seller: string;
  price: BigNumber;
  token: string;
  tokenId: BigNumber;
};

export type StakingStruct = {
  status: BigNumberish;
  maker: string;
  taker: string;
  collateral: BigNumberish;
  premium: BigNumberish;
  startRentalUTC: BigNumberish;
  startStakingUTC: BigNumberish;
  paymentsAmount: BigNumberish;
  tokenPaymentsAmount: BigNumberish;
  deadline: BigNumberish;
  token: string;
  tokenId: BigNumberish;
};

export type StakingStructOutput = [
  number,
  string,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  string,
  BigNumber
] & {
  status: number;
  maker: string;
  taker: string;
  collateral: BigNumber;
  premium: BigNumber;
  startRentalUTC: BigNumber;
  startStakingUTC: BigNumber;
  paymentsAmount: BigNumber;
  tokenPaymentsAmount: BigNumber;
  deadline: BigNumber;
  token: string;
  tokenId: BigNumber;
};

export interface MarketplaceInterface extends utils.Interface {
  functions: {
    "NFTTokenDistributionWhiteLister()": FunctionFragment;
    "NFTsEligibleForTokenDistribution(address)": FunctionFragment;
    "_listings(uint256)": FunctionFragment;
    "_listingsLastIndex()": FunctionFragment;
    "_stakings(uint256)": FunctionFragment;
    "_stakingsLastIndex()": FunctionFragment;
    "bid(address,uint256,uint256)": FunctionFragment;
    "buyToken(uint256)": FunctionFragment;
    "canRentNFT(uint256)": FunctionFragment;
    "cancel(uint256)": FunctionFragment;
    "claimCollateral(uint256)": FunctionFragment;
    "claimTokens(uint256)": FunctionFragment;
    "dateOfNextPayment(uint256)": FunctionFragment;
    "getListing(uint256)": FunctionFragment;
    "getStaking(uint256)": FunctionFragment;
    "isBuyable(uint256)": FunctionFragment;
    "isCollateralClaimable(uint256)": FunctionFragment;
    "maxCollateralEligibleForTokens()": FunctionFragment;
    "nftListingIds(address,uint256)": FunctionFragment;
    "nftStakingIds(address,uint256)": FunctionFragment;
    "payPremium(uint256)": FunctionFragment;
    "paymentsDue(uint256)": FunctionFragment;
    "platform()": FunctionFragment;
    "quoteForStaking(address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "rentNFT(uint256)": FunctionFragment;
    "stopRental(uint256)": FunctionFragment;
    "stopStaking(uint256)": FunctionFragment;
    "tokensDistributionAmount()": FunctionFragment;
    "tokensDistributionEnd()": FunctionFragment;
    "undasToken()": FunctionFragment;
    "whiteListNFTToggle(address,bool)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "NFTTokenDistributionWhiteLister",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "NFTsEligibleForTokenDistribution",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "_listings",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_listingsLastIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_stakings",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_stakingsLastIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bid",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "canRentNFT",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancel",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimCollateral",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "dateOfNextPayment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getListing",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getStaking",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isBuyable",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isCollateralClaimable",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "maxCollateralEligibleForTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftListingIds",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "nftStakingIds",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "payPremium",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "paymentsDue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "platform", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "quoteForStaking",
    values: [string, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rentNFT",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stopRental",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stopStaking",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensDistributionAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokensDistributionEnd",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "undasToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "whiteListNFTToggle",
    values: [string, boolean]
  ): string;

  decodeFunctionResult(
    functionFragment: "NFTTokenDistributionWhiteLister",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "NFTsEligibleForTokenDistribution",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_listings", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_listingsLastIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_stakings", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_stakingsLastIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bid", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buyToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "canRentNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dateOfNextPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getListing", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getStaking", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isBuyable", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isCollateralClaimable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxCollateralEligibleForTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nftListingIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nftStakingIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "payPremium", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "paymentsDue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "platform", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "quoteForStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rentNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stopRental", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stopStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensDistributionAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensDistributionEnd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "undasToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "whiteListNFTToggle",
    data: BytesLike
  ): Result;

  events: {
    "CancelBid(uint256,address)": EventFragment;
    "FinishRentalForCollateral(uint256)": EventFragment;
    "FinishRentalForNFT(uint256)": EventFragment;
    "Listed(uint256,address,address,uint256,uint256)": EventFragment;
    "QuotedForStaking(uint256,address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "Rental(uint256,address)": EventFragment;
    "Sale(uint256,address,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CancelBid"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FinishRentalForCollateral"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FinishRentalForNFT"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Listed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QuotedForStaking"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Rental"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Sale"): EventFragment;
}

export type CancelBidEvent = TypedEvent<
  [BigNumber, string],
  { listingId: BigNumber; seller: string }
>;

export type CancelBidEventFilter = TypedEventFilter<CancelBidEvent>;

export type FinishRentalForCollateralEvent = TypedEvent<
  [BigNumber],
  { rentalId: BigNumber }
>;

export type FinishRentalForCollateralEventFilter =
  TypedEventFilter<FinishRentalForCollateralEvent>;

export type FinishRentalForNFTEvent = TypedEvent<
  [BigNumber],
  { rentalId: BigNumber }
>;

export type FinishRentalForNFTEventFilter =
  TypedEventFilter<FinishRentalForNFTEvent>;

export type ListedEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber],
  {
    listingId: BigNumber;
    seller: string;
    token: string;
    tokenId: BigNumber;
    price: BigNumber;
  }
>;

export type ListedEventFilter = TypedEventFilter<ListedEvent>;

export type QuotedForStakingEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  {
    stakingId: BigNumber;
    maker: string;
    token: string;
    tokenId: BigNumber;
    collateral: BigNumber;
    premium: BigNumber;
    deadline: BigNumber;
  }
>;

export type QuotedForStakingEventFilter =
  TypedEventFilter<QuotedForStakingEvent>;

export type RentalEvent = TypedEvent<
  [BigNumber, string],
  { rentalId: BigNumber; taker: string }
>;

export type RentalEventFilter = TypedEventFilter<RentalEvent>;

export type SaleEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber],
  {
    listingId: BigNumber;
    buyer: string;
    token: string;
    tokenId: BigNumber;
    price: BigNumber;
  }
>;

export type SaleEventFilter = TypedEventFilter<SaleEvent>;

export interface Marketplace extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MarketplaceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    NFTTokenDistributionWhiteLister(
      overrides?: CallOverrides
    ): Promise<[string]>;

    NFTsEligibleForTokenDistribution(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    _listings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, string, BigNumber, string, BigNumber] & {
        status: number;
        seller: string;
        price: BigNumber;
        token: string;
        tokenId: BigNumber;
      }
    >;

    _listingsLastIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    _stakings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber
      ] & {
        status: number;
        maker: string;
        taker: string;
        collateral: BigNumber;
        premium: BigNumber;
        startRentalUTC: BigNumber;
        startStakingUTC: BigNumber;
        paymentsAmount: BigNumber;
        tokenPaymentsAmount: BigNumber;
        deadline: BigNumber;
        token: string;
        tokenId: BigNumber;
      }
    >;

    _stakingsLastIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    bid(
      tokenContract: string,
      tokenId: BigNumberish,
      priceWei: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    buyToken(
      listingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    canRentNFT(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    cancel(
      listingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimCollateral(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimTokens(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    dateOfNextPayment(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { date: BigNumber }>;

    getListing(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[ListingStructOutput]>;

    getStaking(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[StakingStructOutput]>;

    isBuyable(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isCollateralClaimable(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { status: boolean }>;

    maxCollateralEligibleForTokens(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nftListingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & { valueExists: boolean; value: BigNumber }
    >;

    nftStakingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & { valueExists: boolean; value: BigNumber }
    >;

    payPremium(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    paymentsDue(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amountDue: BigNumber }>;

    platform(overrides?: CallOverrides): Promise<[string]>;

    quoteForStaking(
      tokenContract: string,
      tokenId: BigNumberish,
      collateralWei: BigNumberish,
      premiumWei: BigNumberish,
      deadlineUTC: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rentNFT(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    stopRental(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    stopStaking(
      stakingIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tokensDistributionAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    tokensDistributionEnd(overrides?: CallOverrides): Promise<[BigNumber]>;

    undasToken(overrides?: CallOverrides): Promise<[string]>;

    whiteListNFTToggle(
      nft: string,
      whitelist: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  NFTTokenDistributionWhiteLister(overrides?: CallOverrides): Promise<string>;

  NFTsEligibleForTokenDistribution(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  _listings(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, string, BigNumber, string, BigNumber] & {
      status: number;
      seller: string;
      price: BigNumber;
      token: string;
      tokenId: BigNumber;
    }
  >;

  _listingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

  _stakings(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      number,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      string,
      BigNumber
    ] & {
      status: number;
      maker: string;
      taker: string;
      collateral: BigNumber;
      premium: BigNumber;
      startRentalUTC: BigNumber;
      startStakingUTC: BigNumber;
      paymentsAmount: BigNumber;
      tokenPaymentsAmount: BigNumber;
      deadline: BigNumber;
      token: string;
      tokenId: BigNumber;
    }
  >;

  _stakingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

  bid(
    tokenContract: string,
    tokenId: BigNumberish,
    priceWei: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  buyToken(
    listingId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  canRentNFT(
    stakingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  cancel(
    listingId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimCollateral(
    stakingId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimTokens(
    stakingId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  dateOfNextPayment(
    stakingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getListing(
    listingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ListingStructOutput>;

  getStaking(
    stakingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<StakingStructOutput>;

  isBuyable(
    listingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isCollateralClaimable(
    stakingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  maxCollateralEligibleForTokens(overrides?: CallOverrides): Promise<BigNumber>;

  nftListingIds(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber] & { valueExists: boolean; value: BigNumber }>;

  nftStakingIds(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber] & { valueExists: boolean; value: BigNumber }>;

  payPremium(
    stakingId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  paymentsDue(
    stakingId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  platform(overrides?: CallOverrides): Promise<string>;

  quoteForStaking(
    tokenContract: string,
    tokenId: BigNumberish,
    collateralWei: BigNumberish,
    premiumWei: BigNumberish,
    deadlineUTC: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rentNFT(
    stakingId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  stopRental(
    stakingId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  stopStaking(
    stakingIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tokensDistributionAmount(overrides?: CallOverrides): Promise<BigNumber>;

  tokensDistributionEnd(overrides?: CallOverrides): Promise<BigNumber>;

  undasToken(overrides?: CallOverrides): Promise<string>;

  whiteListNFTToggle(
    nft: string,
    whitelist: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    NFTTokenDistributionWhiteLister(overrides?: CallOverrides): Promise<string>;

    NFTsEligibleForTokenDistribution(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    _listings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, string, BigNumber, string, BigNumber] & {
        status: number;
        seller: string;
        price: BigNumber;
        token: string;
        tokenId: BigNumber;
      }
    >;

    _listingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

    _stakings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber
      ] & {
        status: number;
        maker: string;
        taker: string;
        collateral: BigNumber;
        premium: BigNumber;
        startRentalUTC: BigNumber;
        startStakingUTC: BigNumber;
        paymentsAmount: BigNumber;
        tokenPaymentsAmount: BigNumber;
        deadline: BigNumber;
        token: string;
        tokenId: BigNumber;
      }
    >;

    _stakingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

    bid(
      tokenContract: string,
      tokenId: BigNumberish,
      priceWei: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    buyToken(listingId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    canRentNFT(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    cancel(listingId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    claimCollateral(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    claimTokens(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    dateOfNextPayment(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListing(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ListingStructOutput>;

    getStaking(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<StakingStructOutput>;

    isBuyable(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isCollateralClaimable(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    maxCollateralEligibleForTokens(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nftListingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & { valueExists: boolean; value: BigNumber }
    >;

    nftStakingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & { valueExists: boolean; value: BigNumber }
    >;

    payPremium(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    paymentsDue(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    platform(overrides?: CallOverrides): Promise<string>;

    quoteForStaking(
      tokenContract: string,
      tokenId: BigNumberish,
      collateralWei: BigNumberish,
      premiumWei: BigNumberish,
      deadlineUTC: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    rentNFT(stakingId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    stopRental(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    stopStaking(
      stakingIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    tokensDistributionAmount(overrides?: CallOverrides): Promise<BigNumber>;

    tokensDistributionEnd(overrides?: CallOverrides): Promise<BigNumber>;

    undasToken(overrides?: CallOverrides): Promise<string>;

    whiteListNFTToggle(
      nft: string,
      whitelist: boolean,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CancelBid(uint256,address)"(
      listingId?: null,
      seller?: null
    ): CancelBidEventFilter;
    CancelBid(listingId?: null, seller?: null): CancelBidEventFilter;

    "FinishRentalForCollateral(uint256)"(
      rentalId?: null
    ): FinishRentalForCollateralEventFilter;
    FinishRentalForCollateral(
      rentalId?: null
    ): FinishRentalForCollateralEventFilter;

    "FinishRentalForNFT(uint256)"(
      rentalId?: null
    ): FinishRentalForNFTEventFilter;
    FinishRentalForNFT(rentalId?: null): FinishRentalForNFTEventFilter;

    "Listed(uint256,address,address,uint256,uint256)"(
      listingId?: null,
      seller?: null,
      token?: null,
      tokenId?: null,
      price?: null
    ): ListedEventFilter;
    Listed(
      listingId?: null,
      seller?: null,
      token?: null,
      tokenId?: null,
      price?: null
    ): ListedEventFilter;

    "QuotedForStaking(uint256,address,address,uint256,uint256,uint256,uint256)"(
      stakingId?: null,
      maker?: null,
      token?: null,
      tokenId?: null,
      collateral?: null,
      premium?: null,
      deadline?: null
    ): QuotedForStakingEventFilter;
    QuotedForStaking(
      stakingId?: null,
      maker?: null,
      token?: null,
      tokenId?: null,
      collateral?: null,
      premium?: null,
      deadline?: null
    ): QuotedForStakingEventFilter;

    "Rental(uint256,address)"(rentalId?: null, taker?: null): RentalEventFilter;
    Rental(rentalId?: null, taker?: null): RentalEventFilter;

    "Sale(uint256,address,address,uint256,uint256)"(
      listingId?: null,
      buyer?: null,
      token?: null,
      tokenId?: null,
      price?: null
    ): SaleEventFilter;
    Sale(
      listingId?: null,
      buyer?: null,
      token?: null,
      tokenId?: null,
      price?: null
    ): SaleEventFilter;
  };

  estimateGas: {
    NFTTokenDistributionWhiteLister(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    NFTsEligibleForTokenDistribution(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _listings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _listingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

    _stakings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _stakingsLastIndex(overrides?: CallOverrides): Promise<BigNumber>;

    bid(
      tokenContract: string,
      tokenId: BigNumberish,
      priceWei: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    buyToken(
      listingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    canRentNFT(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancel(
      listingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimCollateral(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimTokens(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    dateOfNextPayment(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListing(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaking(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBuyable(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCollateralClaimable(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxCollateralEligibleForTokens(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nftListingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nftStakingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    payPremium(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    paymentsDue(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    platform(overrides?: CallOverrides): Promise<BigNumber>;

    quoteForStaking(
      tokenContract: string,
      tokenId: BigNumberish,
      collateralWei: BigNumberish,
      premiumWei: BigNumberish,
      deadlineUTC: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rentNFT(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    stopRental(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    stopStaking(
      stakingIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tokensDistributionAmount(overrides?: CallOverrides): Promise<BigNumber>;

    tokensDistributionEnd(overrides?: CallOverrides): Promise<BigNumber>;

    undasToken(overrides?: CallOverrides): Promise<BigNumber>;

    whiteListNFTToggle(
      nft: string,
      whitelist: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    NFTTokenDistributionWhiteLister(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    NFTsEligibleForTokenDistribution(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _listings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _listingsLastIndex(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _stakings(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _stakingsLastIndex(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bid(
      tokenContract: string,
      tokenId: BigNumberish,
      priceWei: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    buyToken(
      listingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    canRentNFT(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancel(
      listingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimCollateral(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimTokens(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    dateOfNextPayment(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getListing(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStaking(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBuyable(
      listingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCollateralClaimable(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxCollateralEligibleForTokens(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nftListingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nftStakingIds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    payPremium(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    paymentsDue(
      stakingId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    platform(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    quoteForStaking(
      tokenContract: string,
      tokenId: BigNumberish,
      collateralWei: BigNumberish,
      premiumWei: BigNumberish,
      deadlineUTC: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rentNFT(
      stakingId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    stopRental(
      stakingId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    stopStaking(
      stakingIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tokensDistributionAmount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokensDistributionEnd(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    undasToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whiteListNFTToggle(
      nft: string,
      whitelist: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
